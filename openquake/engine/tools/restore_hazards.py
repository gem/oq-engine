import gzip
import tarfile
import psycopg2
import argparse
import logging
import io
import sys

BLOCKSIZE = 1000  # restore blocks of 1,000 lines each

log = logging.getLogger()


class CSVInserter(object):
    def __init__(self, curs, tablename, blocksize):
        self.curs = curs
        self.tablename = tablename
        self.blocksize = blocksize
        self.max_id = 0
        self.io = io.StringIO()
        self.nlines = 0

    def write(self, id_, line):
        """
        Add a csv line.
        """
        self.max_id = max(self.max_id, id_)
        self.io.write('%d\t%s' % (id_, line.decode('utf8')))
        self.nlines += 1
        if self.max_id % self.blocksize == 0:
            self.insert()

    def insert(self):
        """
        Bulk insert into the database in a single transaction
        """
        self.io.seek(0)
        conn = self.curs.connection
        try:
            self.curs.copy_from(self.io, self.tablename)

            self.curs.execute(
                "select setval('%s_id_seq', (select max(id) from %s))" % (
                    self.tablename, self.tablename))
        except:
            conn.rollback()
            raise
        else:
            conn.commit()
        self.io.truncate(0)
        self.io.seek(0)
        self.max_id = 0

    def __enter__(self):
        return self

    def __exit__(self, etype, exc, tb):
        if self.max_id:  # some remaining line
            self.insert()


def safe_restore(curs, gzfile, tablename, blocksize=BLOCKSIZE):
    """
    Restore a gzipped postgres table into the database, by skipping
    the ids which are already taken. Assume that the first field of
    the table is an integer id and that gzfile.name has the form
    '/some/path/tablename.csv.gz'
    The file is restored in blocks to avoid memory issues.

    :param curs: a psycopg2 cursor
    :param gzfile: a file object
    :param str tablename: full table name
    :param int blocksize: number of lines in a block
    """
    # keep in memory the already taken ids
    curs.execute('select id from %s' % tablename)
    ids = set(r[0] for r in curs.fetchall())
    with CSVInserter(curs, tablename, blocksize) as csvi:
        total = 0
        for line in gzfile:
            total += 1
            sid, rest = line.split('\t', 1)
            id_ = int(sid)
            if id_ not in ids:
                csvi.write(id_, rest)
    return csvi.nlines, total


def hazard_restore(conn, tar):
    """
    Import a tar file generated by the HazardDumper.

    :param conn: the psycopg2 connection to the db
    :param tar: the pathname to the tarfile
    """
    curs = conn.cursor()
    tf = tarfile.open(tar)
    for line in tf.extractfile('hazard_calculation/FILENAMES.txt'):
        fname = line.rstrip()
        tname = fname[:-7]  # strip .csv.gz
        fileobj = tf.extractfile('hazard_calculation/%s' % fname)
        with gzip.GzipFile(fname, fileobj=fileobj) as f:
            log.info('Importing %s...', fname)
            imported, total = safe_restore(curs, f, tname)
            if imported != total:
                log.warn(
                    '%s:%s:\ncould not import %d row(s), id(s) already taken',
                    tf.name, fname, total - imported)
            else:
                log.info('Imported %d new rows', imported)
    log.info('Restored %s', tar)


def hazard_restore_remote(tar, host, dbname, user, password, port):
    conn = psycopg2.connect(
        host=host, dbname=dbname, user=user, password=password, port=port)
    hazard_restore(conn, tar)


def hazard_restore_local(*argv):
    """
    Use the current django settings to restore hazard
    """
    from openquake.engine.db.models import set_django_settings_module
    set_django_settings_module()
    from django.conf import settings
    default_cfg = settings.DATABASES['default']
    host = default_cfg['HOST'] or 'localhost'
    name = default_cfg['NAME']
    user = default_cfg['USER']
    pwd = default_cfg['PASSWORD']
    port = str(default_cfg['PORT'] or 5432)

    def h(dflt):
        return 'default: %s' % dflt

    p = argparse.ArgumentParser()
    p.add_argument('tarfile', help='mandatory argument')
    p.add_argument('host', nargs='?', default=host, help=h(host))
    p.add_argument('dbname', nargs='?', default=name, help=h(name))
    p.add_argument('user', nargs='?', default=user, help=h(user))
    p.add_argument('password', nargs='?', default=pwd, help=h(pwd))
    p.add_argument('port', nargs='?', default=port, help=h(port))
    arg = p.parse_args(argv)

    hazard_restore_remote(arg.tarfile, arg.host, arg.dbname,
                          arg.user, arg.password, arg.port)


if __name__ == '__main__':
    logging.basicConfig(level=logging.WARN)
    hazard_restore_local(*sys.argv[1:])
