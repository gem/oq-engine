# -*- coding: utf-8 -*-

# Copyright (c) 2010-2013, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake.  If not, see <http://www.gnu.org/licenses/>.

"""
Classes dealing with amqp signalling between jobbers, workers and supervisors.
"""
import socket

import kombu
import kombu.entity
import kombu.messaging

from openquake.engine.utils import config


def amqp_connect():
    """
    Connect to amqp broker with kombu using default configuration
    and return connection, channel and exchange as tuple.
    """
    cfg = config.get_section("amqp")
    connection = kombu.BrokerConnection(hostname=cfg['host'],
                                        userid=cfg['user'],
                                        password=cfg['password'],
                                        virtual_host=cfg['vhost'])
    channel = connection.channel()
    exchange = kombu.entity.Exchange(cfg['exchange'], type='topic',
                                     channel=channel)
    exchange.declare()
    return connection, channel, exchange


class AMQPMessageConsumer(object):
    """
    A baseclass to consume logging messages generated by an OpenQuake job.

    Typical use::

        class MyConsumer(AMQPMessageConsumer):
            def message_callback(self, payload, msg):
                # do something usefull
                pass

        MyConsumer('routing.key.#').run()
    """
    def __init__(self, routing_key):
        self.channel = self.connection = None
        self._stopped = False

        self.connection, self.channel, exchange = amqp_connect()
        queue = kombu.entity.Queue(exchange=exchange, channel=self.channel,
                                   routing_key=routing_key, exclusive=True)
        queue.queue_declare()
        queue.queue_bind()
        consumer = kombu.messaging.Consumer(
            self.channel, queue, auto_declare=False)
        consumer.register_callback(self._message_callback)
        consumer.consume()

    def run(self):
        """
        Consumer's main function of execution.
        """
        try:
            while not self._stopped:
                self.connection.drain_events()
        finally:
            self.channel.close()
            self.connection.close()

    def stop(self):
        """
        Stop thread execution on the next loop iteration in :meth:`run`.
        """
        self._stopped = True

    def _message_callback(self, body, msg):  # pylint: disable=W0613
        """
        Run :meth:`message_callback` and handle :exc:`StopIteration` raised
        from there doing :meth:`stop`.
        """
        payload = msg.decode()
        try:
            self.message_callback(payload, msg)
        except StopIteration:
            msg.ack()
            self.stop()
        else:
            msg.ack()

    def message_callback(self, payload, msg):
        """
        Called by :meth:`run` when a message is received.

        Can raise StopIteration to stop the loop inside :meth:`run`
        and terminate execution.
        """
        raise NotImplementedError()
