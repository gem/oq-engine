# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4
"""
Codec for processing vulnerability curves
from XML files.

A DOM version of the vulnerability model parser,
that takes into account the really small size of this input file.

"""

from lxml import etree

from openquake import logs
from openquake import kvs
from openquake import shapes
from openquake.xml import NRML_OLD

LOGGER = logs.RISK_LOG

EMPTY_CODE = 'EMPTY'
VULNERABILITY_CURVE_KEY_TOKEN = 'vulnerability_curves'

def register_vuln_curves(vuln_curves, job_id):
    """This fuction writes a set of vulnerability curves to the kvs system.
    It requires a dict as input, which holds the vulnerability curve codes
    as keys, and the corresponding Curve objects as values.
    job_id is part of the memcache key that points to the curves.
    The function returns a dict with the curves."""

    # get already registered curves
    vulnerability_curves = load_vuln_curves_from_kvs(job_id)

    # append new curves, or update existing curves
    vulnerability_curves.update(vuln_curves)

    # write to memcache
    write_vuln_curves_to_kvs(job_id, vulnerability_curves)

    return vulnerability_curves

def delete_vuln_curves(job_id):
    """Deletes vulnerability curves for a given job_id from the kvs system."""
    kvs.get_client(binary=False).delete(kvs.tokens.vuln_key(job_id))

def load_vulnerability_model(job_id, path):
    """Loads and registers all the vulnerability functions defined."""

    vulnerability_curves = {}

    # register empty curve
    vulnerability_curves[EMPTY_CODE] = shapes.EMPTY_VULN_FUNCTION.to_json()

    vulnerability_model = etree.parse(path).getroot()

    intensity_measure_values = [float(x) for x in
            vulnerability_model.find(
            ".//%sValues" % NRML_OLD).text.strip().split()]
    
    for vulnerability_function in vulnerability_model.findall(
            ".//%sDiscreteVulnerability" % NRML_OLD):

        loss_ratio_values = [float(x) for x in
                vulnerability_function.find(
                '%sLossRatios' % NRML_OLD).text.strip().split()]
                
        coefficient_variation_values = [float(x) for x in
                vulnerability_function.find(
                '%sCoefficientsVariation' % NRML_OLD).text.strip().split()]

        # convert raw values into our object model
        curve_data = []
        pairs = zip(loss_ratio_values, coefficient_variation_values)
        
        for idx, iml in enumerate(intensity_measure_values):
            curve_data.append(('%s' % iml, pairs[idx]))

        vulnerability_curves[vulnerability_function.attrib['ID']] = \
            shapes.VulnerabilityFunction(curve_data).to_json()

    write_vuln_curves_to_kvs(job_id, vulnerability_curves)

def write_vuln_curves_to_kvs(job_id, vulnerability_curves):
    """ JSON encode vulnerability curve and write to KVS """
    success = kvs.set_value_json_encoded(kvs.tokens.vuln_key(job_id), 
        vulnerability_curves)

    if success is not True:
        raise RuntimeError(
            "Vulnerability module: cannot write "
            "vulnerability functions to the kvs")

def load_vuln_curves_from_kvs(job_id):
    """ Get JSON decoded vulnerability curve from kvs """
    vulnerability_curves_mc = kvs.get_value_json_decoded(
        kvs.tokens.vuln_key(job_id))

    vulnerability_curves = {}

    if vulnerability_curves_mc is not None:
        for k, v in vulnerability_curves_mc.items():
            vulnerability_curves["%s" % k] = \
                    shapes.VulnerabilityFunction.from_json(v)

    return vulnerability_curves
