# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright (c) 2010-2011, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License version 3
# only, as published by the Free Software Foundation.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License version 3 for more details
# (a copy is included in the LICENSE file that accompanied this code).
#
# You should have received a copy of the GNU Lesser General Public License
# version 3 along with OpenQuake.  If not, see
# <http://www.gnu.org/licenses/lgpl-3.0.txt> for a copy of the LGPLv3 License.



"""
Codec for processing vulnerability curves
from XML files.

A DOM version of the vulnerability model parser,
that takes into account the really small size of this input file.
"""

from lxml import etree

from openquake import kvs
from openquake import shapes
from openquake.xml import NRML
from openquake import producer


def _parse_set_attributes(vulnerability_set):
    """Parse and return the attributes for all the
    vulnerability functions defined in this set of the NRML file."""

    imls = vulnerability_set.find(".//%sIML" % NRML)

    vuln_function = {"IMT": imls.attrib["IMT"]}

    vuln_function["IML"] = \
            [float(x) for x in imls.text.strip().split()]

    vuln_function["vulnerabilitySetID"] = \
            vulnerability_set.attrib["vulnerabilitySetID"]

    vuln_function["assetCategory"] = \
            vulnerability_set.attrib["assetCategory"]

    vuln_function["lossCategory"] = \
            vulnerability_set.attrib["lossCategory"]
            
    return vuln_function


class VulnerabilityModelFile(producer.FileProducer):
    """This class parsers a vulnerability model NRML file.
    
    The class is implemented as a generator. For each vulnerability
    function in the parsed instance document it yields a dictionary
    with all the data defined for that function.
    """

    def __init__(self, path):
        producer.FileProducer.__init__(self, path)
        self.vuln_model = etree.parse(self.path).getroot()

    def filter(self, region_constraint=None, attribute_constraint=None):
        """Filtering is not needed/supported for the vulnerability model."""

    def _parse(self):
        """Parse the vulnerability model."""

        for vuln_set in self.vuln_model.findall(
                ".//%sdiscreteVulnerabilitySet" % NRML):

            vuln_function = _parse_set_attributes(vuln_set)

            for raw_vuln_function in vuln_set.findall(
                    ".//%sdiscreteVulnerability" % NRML):

                loss_ratios = [float(x) for x in
                        raw_vuln_function.find(
                        "%slossRatio" % NRML).text.strip().split()]

                coefficients_variation = [float(x) for x in
                        raw_vuln_function.find(
                        "%scoefficientsVariation" % NRML)
                        .text.strip().split()]

                vuln_function["ID"] = \
                        raw_vuln_function.attrib["vulnerabilityFunctionID"]

                vuln_function["probabilisticDistribution"] = \
                        raw_vuln_function.attrib["probabilisticDistribution"]

                vuln_function["lossRatio"] = loss_ratios
                vuln_function["coefficientsVariation"] = coefficients_variation
                
                yield dict(vuln_function)


# TODO (ac): These two functions should be probably moved elsewhere
def load_vulnerability_model(job_id, path):
    """Load and store the vulnerability model defined in the
    given NRML file in the underlying kvs system."""

    vulnerability_model = {}
    parser = VulnerabilityModelFile(path)

    for vulnerability_curve in parser:
        curve = []
        
        data = zip(vulnerability_curve["lossRatio"],
                vulnerability_curve["coefficientsVariation"])

        for idx, iml in enumerate(
                vulnerability_curve["IML"]):

            curve.append((iml, data[idx]))

        vulnerability_model[vulnerability_curve["ID"]] = \
                shapes.VulnerabilityFunction(curve).to_json()

    kvs.set_value_json_encoded(kvs.tokens.vuln_key(job_id), 
            vulnerability_model)


def load_vuln_model_from_kvs(job_id):
    """Load the vulnerability model from kvs for the given job."""

    vulnerability_model = kvs.get_value_json_decoded(
            kvs.tokens.vuln_key(job_id))

    vulnerability_curves = {}

    if vulnerability_model is not None:
        for k, v in vulnerability_model.items():
            vulnerability_curves[k] = shapes.VulnerabilityFunction.from_json(v)

    return vulnerability_curves
