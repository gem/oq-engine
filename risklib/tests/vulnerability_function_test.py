# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright (c) 2010-2012, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake.  If not, see <http://www.gnu.org/licenses/>.

import json
import unittest
import numpy

from risklib.vulnerability_function import VulnerabilityFunction


class VulnerabilityFunctionTestCase(unittest.TestCase):
    """
    Test for :py:class:`risklib.vulnerability_function.VulnerabilityFunction`.
    """
    IMLS_GOOD = [0.005, 0.007, 0.0098, 0.0137, 0.0192, 0.0269]
    IMLS_BAD = [-0.1, 0.007, 0.0098, 0.0137, 0.0192, 0.0269]
    IMLS_DUPE = [0.005, 0.005, 0.0098, 0.0137, 0.0192, 0.0269]
    IMLS_BAD_ORDER = [0.005, 0.0098, 0.007, 0.0137, 0.0192, 0.0269]

    LOSS_RATIOS_GOOD = [0.1, 0.3, 0.0, 0.5, 1.0, 0.6]
    LOSS_RATIOS_BAD = [0.1, 0.3, 0.0, 1.1, -0.1, 0.6]
    LOSS_RATIOS_TOO_SHORT = [0.1, 0.3, 0.0, 0.5, 1.0]
    LOSS_RATIOS_TOO_LONG = [0.1, 0.3, 0.0, 0.5, 1.0, 0.6, 0.5]

    COVS_GOOD = [0.3, 0.1, 0.3, 0.0, 0.3, 10]
    COVS_BAD = [-0.1, 0.1, 0.3, 0.0, 0.3, 10]
    COVS_TOO_SHORT = [0.3, 0.1, 0.3, 0.0, 0.3]
    COVS_TOO_LONG = [0.3, 0.1, 0.3, 0.0, 0.3, 10, 11]

    @classmethod
    def setUpClass(cls):
        cls.test_func = VulnerabilityFunction(cls.IMLS_GOOD,
            cls.LOSS_RATIOS_GOOD, cls.COVS_GOOD, "LN")

    def test_vuln_func_constructor_with_good_input(self):
        """
        This test exercises the VulnerabilityFunction constructor with
        known-good input.
        """
        VulnerabilityFunction(self.IMLS_GOOD, self.LOSS_RATIOS_GOOD,
            self.COVS_GOOD, "LN")

    def test_vuln_func_constructor_raises_on_bad_imls(self):
        """
        This test attempts to invoke AssertionErrors by passing 3 different
        sets of bad IMLs to the constructor:
            - IML list containing out-of-range value(s)
            - IML list containing duplicates
            - IML list ordered improperly
        """
        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_BAD, self.LOSS_RATIOS_GOOD, self.COVS_GOOD, "LN")

        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_DUPE, self.LOSS_RATIOS_GOOD, self.COVS_GOOD, "LN")

        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_BAD_ORDER, self.LOSS_RATIOS_GOOD, self.COVS_GOOD, "LN")

    def test_vuln_func_constructor_raises_on_bad_cov(self):
        """
        This test attempts to invoke AssertionErrors by passing 3 different
        sets of bad CoV values to the constructor:
            - CoV list containing out-range-values
            - CoV list which is shorter than the IML list
            - CoV list which is longer than the IML list
        """
        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_BAD, "LN")

        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_TOO_SHORT, "LN")

        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_TOO_LONG, "LN")

    def test_vuln_func_constructor_raises_on_bad_loss_ratios(self):
        """
        This test attempts to invoke AssertionErrors by passing 3 different
        sets of bad loss ratio values to the constructor:
            - loss ratio list containing out-range-values
            - loss ratio list which is shorter than the IML list
            - loss ratio list which is longer than the IML list
        """
        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_BAD, self.COVS_GOOD, "LN")

        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_TOO_SHORT, self.COVS_GOOD, "LN")

        self.assertRaises(AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_TOO_LONG, self.COVS_GOOD, "LN")

    def test_from_tuple(self):
        """
        Test that a VulnerabilityFunction can be created from a tuple
        of values
        """
        data_dict = {
            '0.005': [0.1, 0.2],
            '0.007': [0.3, 0.4],
            0.0098: [0.5, 0.6]}

        vuln_curve = VulnerabilityFunction.from_tuple(("BT", data_dict))

        self.assertEqual([0.005, 0.007, 0.0098], vuln_curve._imls)
        self.assertEqual([0.1, 0.3, 0.5], vuln_curve._loss_ratios)
        self.assertEqual([0.2, 0.4, 0.6], vuln_curve._covs)
        self.assertEqual("BT", vuln_curve.distribution)

    def test_from_json(self):
        """
        Test that a VulnerabilityFunction can be constructed from a
        properly formatted JSON string.
        """
        vuln_func_json = '["BT", {"0.005": [0.1, 0.2], "0.007": [0.3, 0.4], "0.0098": [0.5, 0.6]}]'

        vuln_curve = VulnerabilityFunction.from_json(vuln_func_json)

        self.assertEqual([0.005, 0.007, 0.0098], vuln_curve._imls)
        self.assertEqual([0.1, 0.3, 0.5], vuln_curve._loss_ratios)
        self.assertEqual([0.2, 0.4, 0.6], vuln_curve._covs)
        self.assertEqual("BT", vuln_curve.distribution)

    def test_to_json(self):
        """
        Test that a VulnerabilityFunction can produce a correct JSON
        representation of itself.
        """
        imls = [0.005, 0.007, 0.0098]
        loss_ratios = [0.1, 0.3, 0.5]
        covs = [0.2, 0.4, 0.6]

        vuln_func = VulnerabilityFunction(imls, loss_ratios, covs, "LN")

        expected_json = '["LN", {"0.005": [0.1, 0.2], "0.007": [0.3, 0.4], "0.0098": [0.5, 0.6]}]'

        # The JSON data (which is essentially a dict) may not come out with the
        # data ordered in a predictable way. So, we'll decode the expected and
        # actual values and compare them as dicts.

        json_decoder = json.JSONDecoder()

        self.assertEqual(
            json_decoder.decode(expected_json),
            json_decoder.decode(vuln_func.to_json()))

    def test_eq(self):
        """
        Exercise equality comparison of VulnerabilityFunctions. Two functions
        created with the same IML, Loss Ratio, and CoV values should be
        considered equal.
        """
        imls = [0.005, 0.007]
        loss_ratios = [0.0, 1.0]
        covs = [0.05, 0.05]

        func1 = VulnerabilityFunction(imls, loss_ratios, covs, "LN")
        func2 = VulnerabilityFunction(imls, loss_ratios, covs, "LN")

        self.assertEqual(func1, func2)

    def test_loss_ratio_interp_single_value(self):
        """
        Test that single loss ratio values are properly interpolated.
        """
        # lower boundary:
        self.assertEqual(0.1, self.test_func.loss_ratio_for(0.005))
        # upper boundary:
        self.assertEqual(0.6, self.test_func.loss_ratio_for(0.0269))
        # between the first 2 IMLs:
        self.assertEqual(0.2, self.test_func.loss_ratio_for(0.006))

    def test_loss_ratio_interp_single_value_clipped(self):
        """
        Test that loss ratio interpolation properly clips out-of-range input
        values to the IML range defined for the vulnerability function.
        """
        # test low-end clipping:
        self.assertEqual(0.0, self.test_func.loss_ratio_for(0.0049))
        # test high-end clipping:
        self.assertEqual(0.6, self.test_func.loss_ratio_for(0.027))

    def test_loss_ratio_interp_many_values(self):
        """
        Given a list of IML values (abscissae), test for proper interpolation
        of loss ratios (ordinates).
        """
        expected_lrs = numpy.array([0.1, 0.2, 0.6])
        test_input = [0.005, 0.006, 0.0269]

        self.assertTrue(numpy.allclose(expected_lrs,
            self.test_func.loss_ratio_for(test_input)))
        # same thing, except the input is a numpy.ndarray type:
        self.assertTrue(numpy.allclose(expected_lrs,
            self.test_func.loss_ratio_for(numpy.array(test_input))))

    def test_loss_ratio_interp_many_values_clipped(self):
        """
        Given a list of IML values (abscissae), test for proper interpolation
        of loss ratios (ordinates).

        This test also ensures that input IML values are 'clipped' to the IML
        range defined for the vulnerability function.
        """
        expected_lrs = numpy.array([0.0, 0.2, 0.6])
        test_input = [0.0049, 0.006, 0.027]

        self.assertTrue(numpy.allclose(expected_lrs,
            self.test_func.loss_ratio_for(test_input)))
        # same thing, except the input is a numpy.ndarray type:
        self.assertTrue(numpy.allclose(expected_lrs,
            self.test_func.loss_ratio_for(numpy.array(test_input))))

    def test_cov_interp_single_value(self):
        """
        Test that single CoV values are properly interpolated.
        """
        # lower boundary:
        self.assertEqual(0.3, self.test_func.cov_for(0.005))
        # upper boundary:
        self.assertEqual(10, self.test_func.cov_for(0.0269))
        # between the first 2 IMLs:
        self.assertEqual(0.2, self.test_func.cov_for(0.006))

    def test_cov_interp_single_value_clipped(self):
        """
        Test that CoV interpolation properly clips out-of-range input values
        to the IML range defined for the vulnerability function.
        """
        # test low-end clipping:
        self.assertEqual(0.3, self.test_func.cov_for(0.0049))
        # test high-end clipping:
        self.assertEqual(10, self.test_func.cov_for(0.027))

    def test_cov_interp_many_values(self):
        """
        Given a list of IML values (abscissae), test for proper interpolation
        of CoVs.
        """
        expected_covs = numpy.array([0.3, 0.2, 10])
        test_input = [0.005, 0.006, 0.0269]

        self.assertTrue(numpy.allclose(expected_covs,
            self.test_func.cov_for(test_input)))
        # same thing, except the input is a numpy.ndarray type:
        self.assertTrue(numpy.allclose(expected_covs,
            self.test_func.cov_for(numpy.array(test_input))))

    def test_cov_interp_many_values_clipped(self):
        """
        Given a list of IML values (abscissae), test for proper interpolation
        of CoVs.

        This test also ensures that input IML values are 'clipped' to the IML
        range defined for the vulnerability function.
        """
        expected_covs = numpy.array([0.3, 0.2, 10])
        test_input = [0.0049, 0.006, 0.027]

        self.assertTrue(numpy.allclose(expected_covs,
            self.test_func.cov_for(test_input)))
        # same thing, except the input is a numpy.ndarray type:
        self.assertTrue(numpy.allclose(expected_covs,
            self.test_func.cov_for(numpy.array(test_input))))

    def test_is_empty(self):
        """
        Test the 'is_empty' property of a vulnerability function.
        """
        empty_func = VulnerabilityFunction([], [], [], "LN")

        # Test empty function:
        self.assertTrue(empty_func.is_empty)

        # Test non-empty function:
        self.assertFalse(self.test_func.is_empty)

    def test_iter(self):
        """
        Test iterability of a vulnerability function.
        """
        expected = zip(self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_GOOD)

        # iterate and accumulate all of the vuln function values:
        actual = [x for x in self.test_func]

        self.assertEqual(expected, actual)

    def test_is_beta(self):
        log_normal = VulnerabilityFunction([], [], [], "LN")

        self.assertFalse(log_normal.is_beta)

        beta = VulnerabilityFunction([], [], [], "BT")
        self.assertTrue(beta.is_beta)
