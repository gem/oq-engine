
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Fil Memory Profile (Wed Apr 27 12:58:23 2022)</title>
  <style type="text/css">
    body {
        font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;
        line-height: 1.2;
        max-width: 40rem;
        margin: 4rem auto;
        font-size: 18px;
    }
    blockquote { border-width: 1px; border-color: black; border-style: solid; padding: 1em; }
    div {
        text-align: center;
    }
  </style>
  <script>
   function compatRequestFullscreen(elem) {
       if (elem.requestFullscreen) {
           return elem.requestFullscreen();
       } else if (elem.webkitRequestFullscreen) {
           return elem.webkitRequestFullscreen();
       } else if (elem.mozRequestFullScreen) {
           return elem.mozRequestFullScreen();
       } else if (elem.msRequestFullscreen) {
           return elem.msRequestFullscreen();
       }
   }
   function fullScreen(id) {
       var elem = document.querySelector(id);
       var currentHeight = elem.style.height;
       elem.style.height = "100%";
       compatRequestFullscreen(elem).finally(
           (info) => {elem.style.height = currentHeight;}
       );
   }
  </script>
</head>
<body>
<h1>Fil Memory Profile</h1>
<h2>Wed Apr 27 12:58:23 2022</h2>
<h2>Command</h2>
<p><code>openquake/commands/__main__.py engine --run ../../nzshm-runzi/docker/runzi-openquake/examples/27_TAG_CONFIG/job.ini</code><p>

<h2>Profiling result</h2>
<div><p><input type="button" onclick="fullScreen('#peak');" value="Full screen"> · <a href="peak-memory.svg" target="_blank"><button>Open in new window</button></a></p>
<iframe id="peak" src="peak-memory.svg" width="100%" height="400" scrolling="auto" frameborder="0"></iframe><br>
</div>
<br>
<br>
<hr>
<br>
<div><p><input type="button" onclick="fullScreen('#peak-reversed');" value="Full screen"> · <a href="peak-memory-reversed.svg" target="_blank"><button>Open in new window</button></a></p>
            <iframe id="peak-reversed" src="peak-memory-reversed.svg" width="100%" height="400" scrolling="auto" frameborder="0"></iframe><br>
</div>
<br>
<blockquote><strong>Need help, or does something look wrong?</strong>
<a href="https://pythonspeed.com/fil/docs/">Read the documentation</a>,
and if that doesn't help please
<a href="https://github.com/pythonspeed/filprofiler/issues/new?body=%23%23+Version+information%0AFil%3A+2022.3.0%0APython%3A+3.8.10+%28default%2C+Mar+15+2022%2C+12%3A22%3A08%29+%0A%5BGCC+9.4.0%5D%0A">file an issue</a>
and I'll try to help.</blockquote>
<br>
<blockquote><strong>Want memory and performance profiling for your production batch jobs?</strong>
I've also created an
<a href="https://pythonspeed.com/sciagraph/"
>always-on profiler called Sciagraph</a> that is fast and robust enough to run in production.</blockquote>
<br>

<h2>Learn how to reduce memory usage</h2>

<p>Need help reducing your data processing application's memory use? Check out tips and tricks <a href="https://pythonspeed.com/memory/">here</a>.</p>

<h2>Understanding the graphs</h2>
<p>The flame graphs shows the callstacks responsible for allocations at peak.</p>

<p>The wider (and the redder) the bar, the more memory was allocated by that function or its callers.
If the bar is 100% of width, that's all the allocated memory.</p>

<p>The left-right axis has no meaning!
The order of frames is somewhat arbitrary, for example beause multiple calls to the same function may well have been merged into a single callstack.
So you can't tell from the graph which allocations happened first.
All you're getting is that at peak allocation these time, these stacktraces were responsible for these allocations.
</p>

<p>The first graph shows the normal callgraph: if <tt>main()</tt> calls <tt>g()</tt> calls <tt>f()</tt>, let's say, then <tt>main()</tt> will be at the top.
The second graph shows the reverse callgraph, from <tt>f()</tt> upwards.</p>

<p>Why is the second graph useful? If <tt>f()</tt> is called from multiple places, in the first graph it will show up multiple times, at the bottom.
In the second reversed graph all calls to <tt>f()</tt> will be merged together.</p>

<h2>Understanding what Fil tracks</h2>

<p>Fil measures how much memory has been allocated; this is not the same as how much memory the process is actively using, nor is it the same as memory resident in RAM.</p>

<ul>
<li>If the data gets dumped from RAM to swap, Fil still counts it but it's not counted as resident in RAM.</li>
<li>If the memory is a large chunk of all zeros, on Linux no RAM is used by OS until you actually modify that memory, but Fil will still count it.</li>
<li>If you have memory that only gets freed on garbage collection
(this will happen if you have circular references in your data structures),
memory can be freed at inconsistent times across different runs, especially
if you're using threads.</li>
</ul>

<p>See <a href="https://pythonspeed.com/articles/measuring-memory-python/">this article</a> for more details.</p>

</body>
</html>
