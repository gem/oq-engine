# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4
"""Codec for processing vulnerability curves
from XML files.

A DOM version of the vulnerability model parser,
that takes into account the really small size of this input file.

"""

import json

from lxml import etree
from ordereddict import OrderedDict

from opengem import identifiers
from opengem import logs
from opengem import memcached
from opengem import shapes

logger = logs.RISK_LOG

EMPTY_CODE = 'EMPTY'

def register_vuln_curves(vuln_curves, job_id, memcache_client=None):
    """This fuction writes a set of vulnerability curves to memcache.
    It requires a dict as input, which holds the vulnerability curve codes
    as keys, and the corresponding FastCurve objects as values.
    job_id is part of the memcache key that points to the curves.
    The function returns a dict with the curves."""

    #old input values: vuln_curve_code, vuln_curve
    if memcache_client is None:
        memcache_client = memcached.get_client(binary=False)

    # get already registered curves
    vulnerability_curves = \
        load_vulnerability_curves_from_memcache(memcache_client, job_id)

    # append new curves, or update existing curves
    vulnerability_curves.update(vuln_curves)

    # write to memcache
    write_vulnerability_curves_to_memcache(memcache_client, job_id,
                                           vulnerability_curves)

    return vulnerability_curves

def delete_vuln_curves(job_id, memcache_client=None):
    """Deletes vulnerability curves for a given job_id from memcache."""

    if memcache_client is None:
        memcache_client = memcached.get_client(binary=False)

    memcache_client.delete(generate_memcache_key(job_id))

def load_vulnerability_model(job_id, path, memcache_client=None):
    """Loads and registers all the vulnerability functions defined."""

    vulnerability_curves = {}

    # register empty curve
    vulnerability_curves[EMPTY_CODE] = shapes.EMPTY_CURVE.to_json()

    vulnerability_model = etree.parse(path).getroot()
    for vulnerability_function in vulnerability_model:
        # parse values
        intensity_measure_values = [float(x) for x in
                vulnerability_function.find(
                'IntensityMeasureValues').text.strip().split()]
        
        loss_ratio_values = [float(x) for x in
                vulnerability_function.find(
                'LossRatioValues').text.strip().split()]
                
        coefficient_variation_values = [float(x) for x in
                vulnerability_function.find(
                'CoefficientVariationValues').text.strip().split()]

        # convert raw values into our object model
        curve_data = []
        pairs = zip(loss_ratio_values, coefficient_variation_values)
        
        for idx, IML in enumerate(intensity_measure_values):
            curve_data.append(('%s' % IML, pairs[idx]))

        vulnerability_curves[vulnerability_function.attrib['ID']] = \
            shapes.FastCurve(curve_data).to_json()

    # write curves to memcache
    if memcache_client is None:
        memcache_client = memcached.get_client(binary=False)

    write_vulnerability_curves_to_memcache(memcache_client, job_id,
                                           vulnerability_curves)

def generate_memcache_key(job_id):
    return identifiers.MEMCACHE_KEY_SEPARATOR.join(
        (str(job_id), identifiers.VULNERABILITY_CURVE_KEY_TOKEN))

def write_vulnerability_curves_to_memcache(memcache_client, job_id,
                                           vulnerability_curves):
    success = memcache_client.set(generate_memcache_key(job_id), 
                                  vulnerability_curves)

    if success is not True:
        raise RuntimeError(
            "vulnerability: cannot write vulnerability functions to memcache")

def load_vulnerability_curves_from_memcache(memcache_client, job_id):

    vulnerability_curves_mc = memcache_client.get(
        generate_memcache_key(job_id))

    # convert JSON values to FastCurves
    # curve abscissa values have to be in ascending order
    # it seems that order of items is corrupted in the memcache step
    # usage of OrderedDict SUCKS! have to replace with numpy.array ASAP
    vulnerability_curves = {}
    decoder = json.JSONDecoder()
    if vulnerability_curves_mc is not None:
        for k, v in vulnerability_curves_mc.items():
            decoded_unordered_curve = decoder.decode(v)
            ordered_keys = map(str, 
                sorted(map(float, decoded_unordered_curve.keys())))

            curve_data = []
            for curve_key in ordered_keys:
                curve_data.append(('%s' % curve_key, 
                                   decoded_unordered_curve[curve_key]))
        
            curve = shapes.FastCurve(curve_data)

            logger.debug("adding curve %s: %s" % (k, curve.values))
            vulnerability_curves["%s" % k] = curve

    return vulnerability_curves
