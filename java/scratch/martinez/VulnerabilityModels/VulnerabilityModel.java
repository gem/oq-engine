package scratch.martinez.VulnerabilityModels;

import java.util.ArrayList;
import java.util.TreeMap;

import org.opensha.commons.data.function.ArbitrarilyDiscretizedFunc;
import org.opensha.commons.data.function.DiscretizedFunc;
import org.opensha.sha.imr.param.IntensityMeasureParams.PGA_Param;
import org.opensha.sha.imr.param.IntensityMeasureParams.SA_Param;

import scratch.martinez.Trackable;
import scratch.martinez.StructureTypes.StructureType;


/**
 * Represents a probabilistic relationship between an intensity measure level (IML) and
 * damage factor (DF) for a given structure type.  Flexible enough to be used for
 * modeling vulnerability for earthquake, wind, flood, or other hazards.
 * 
 * @author <a href="mailto:emartinez@usgs.gov">Eric Martinez</a>
 * @author Keith Porter
 *
 */
public abstract class VulnerabilityModel implements Trackable {
	/* These variables are useful for implementing the Trackable Interface **/
	private static ArrayList<Trackable> registeredTypes = new ArrayList<Trackable>();
	private static TreeMap<String, ArrayList<Trackable>> tracker = new TreeMap<String, ArrayList<Trackable>>();
	// A list of fully qualified class names that the implementing Vulnerability Supports (i.e. IMTs, StructureTypes)
	protected ArrayList<String> supportedTypes = null;
	
	/* These variables are useful for implementing VulnerabilityFunctions */
	protected static final String SA = SA_Param.NAME;
	protected static final String PGA = PGA_Param.NAME;
	private double period = 0.0;
	
	protected double ADF;
	protected double BDF;
	protected int NIML;
	
	////////////////////////////////////////////////////////////////////////////////
	//                    Minimum Functions to Implement Trackable                //
	////////////////////////////////////////////////////////////////////////////////
	/**
	 * See the generic contract in Trackable.
	 * @see Trackable
	 */
	public ArrayList<Trackable> getRegisteredTypes() {
		return registeredTypes;
	}

	/**
	 * See the generic contract in Trackable.
	 * @see Trackable
	 */
	public ArrayList<Trackable> getSupportedTypes(Trackable obj) {
		String tId = obj.getTrackableId();
		ArrayList<Trackable> rtn = null;
		if(tracker.containsKey(tId)) {
			rtn = tracker.get(tId);
		}
		return rtn;
	}

	/**
	 * See the generic contract in Trackable.
	 * @see Trackable
	 */
	public String getTrackableId() {
		String str = (this.getClass()).toString();
		return str.substring(6);
	}

	/**
	 * See the generic contract in Trackable.
	 * @see Trackable
	 */
	public void register(ArrayList<String> types) {
		Trackable t = (Trackable) this;
		
		// Add this to the list of known registered types.
		if(registeredTypes.indexOf(t) == -1)
			registeredTypes.add(t);
		
		// Add all the supported types to the tracker
		for(int i = 0; i < types.size(); ++i) {
			String type = types.get(i);
			ArrayList<Trackable> supported = tracker.get(type);
			if(supported == null)
				supported = new ArrayList<Trackable>();
			supported.add(t);
			tracker.put(type, supported);
		}
	}
	
	/**
	 * See the generic contract in Trackable.
	 * @see Trackable
	 */
	public boolean equals(Object o) {
		if(o == null) return false;
		if(! (o instanceof StructureType) ) return false;
		String tId = this.getTrackableId();
		String oId = (o.getClass().toString()).substring(6);
		return tId.equals(oId);
	}
	
	
	////////////////////////////////////////////////////////////////////////////////
	//                               Public Functions                             //
	////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * @return An <code>ArrayList</code> of currently registered <code>VulnerabilityModel</code>s
	 */
	public ArrayList<StructureType> getLibraryOfTypes() {
		ArrayList<StructureType> st = new ArrayList<StructureType>();
		for(int i = 0; i < registeredTypes.size(); ++i) {
			st.add( ( (StructureType) registeredTypes.get(i) ) );
		}
		return st;
	}
	
	/**
	 * @return An <code>ArrayList</code> of types supported by one or more of the
	 * currently registered <code>VulnerabilityModels</code>
	 */
	public ArrayList<String> getSupportedTypes() {
		return supportedTypes;
	}
	
	/**
	 * @return The lower bound of the Damage Factor values associated with the implementing model
	 */
	public double getADF() {
		return ADF;
	}
	
	/**
	 * @return The upper bound of the Damage Factor values associated with the implementing model
	 */
	public double getBDF() {
		return BDF;
	}

	/**
	 * @return The return period for the implementing model.
	 */
	public double getPeriod() {
		return period;
	}

	/**
	 * Sets the return period to <code>period</code>
	 * @param period The new return period (in years).
	 */
	public void setPeriod(double period) {
		this.period = period;
	}
	
	/**
	 * @return The cannonical name used to describe this Vulnerability Model.
	 */
	public abstract String getDisplayName();

	/**
	 * Fetches the IML values out of the DF Lookup Table.
	 * @return An <code>ArrayList</code> of doubles representing the
	 * IML values for the current Vulnerability Model.
	 */
	public ArrayList<Double> getIMLVals() {
		ArrayList<double[]> tmp = getDFTable();
		ArrayList<Double> rtn = new ArrayList<Double>();
		
		for(int i = 0; i < tmp.size(); ++i) {
			double[] entry = tmp.get(i);
			rtn.add(entry[0]);
		}
		return rtn;
	}
	
	/**
	 * Gets the IML values and DF values and maps them into the X,Y
	 * values (respectively) of a new <code>DiscretizedFunc</code>.
	 * 
	 * @return A <code>DiscretizedFunc</code> with X,Y values corresponding
	 * to the IML,DF values respectively.  The function will have NIML points.
	 */
	public DiscretizedFunc getVulnerabilityFunc() {
		ArrayList<Double> IMLs = getIMLVals();
		ArrayList<Double> DFs = getDFVals();
		DiscretizedFunc func = new ArbitrarilyDiscretizedFunc();
		String name = getTrackableId().replaceAll("/^.*\\./", "");
		String info = getTrackableId() + "," + getIMT() + "," + getNIML();
		
		func.setName(name);
		func.setInfo(info);
		for(int i = 0; i < getNIML(); ++i)
			func.set(IMLs.get(i), DFs.get(i));
		
		return func;
	}
	
	/**
	 * Gets the IML values associated with the current VulnerabilityModel.  And puts
	 * them into the X-values of a new </code>DiscretizedFunc</code> object.  The 
	 * Y-values are all initialized to zero.
	 * 
	 * @return A new <code>DiscretizedFunc</code> with X-values representing the IML
	 * values for the current Vulnerability Model, and Y-Values all set to Zero.
	 */
	public DiscretizedFunc getHazardTemplate() {
		ArrayList<Double> IMLs = getIMLVals();
		DiscretizedFunc rtn = new ArbitrarilyDiscretizedFunc();
		
		for(int i = 0; i < getNIML(); ++i)
			rtn.set(IMLs.get(i), 0.0);
		return rtn;
	}
	
	/**
	 * Fetches the DF values out of the DF Lookup Table.
	 * @return An <code>ArrayList</code> of doubles representing the
	 * DF values for the current Vulnerability Model.
	 */
	public ArrayList<Double> getDFVals() {
		ArrayList<double[]> tmp = getDFTable();
		ArrayList<Double> rtn = new ArrayList<Double>();
		
		for(int i = 0; i < tmp.size(); ++i) {
			double[] entry = tmp.get(i);
			rtn.add(entry[1]);
		}
		return rtn;
	}
	
	/**
	 * @return The number of Intensity Measure Levels for the current Vulnerability Model.
	 */
	public double getNIML() {
		return NIML;
	}
	
	////////////////////////////////////////////////////////////////////////////////
	//                             Abstract Functions                             //
	////////////////////////////////////////////////////////////////////////////////
	

	
	/**
	 * @return The Intensity Measure Type used with the current Vulnerability Model.
	 */
	public abstract String getIMT();
	
	/**
	 * The DF Lookup Table has dimension NIML x 3 and holds the IML, MDF, and COV
	 * values associated with the current Vulnerability Model.  The structure of
	 * this table is as follows:<br />
	 * <pre>
	 * 			\________________________________________________
	 * 		IML  |  IML1	IML2	IML3	....	IML(NIML)
	 * 		MDF  |	MDF1	MDF2	MDF3	....	MDF(NIML)
	 * 		COV  |	COV1	COV2	COV3	....	COV(NIML
	 * </pre>
	 * @return The DF lookup table used with the current Vulnerability Model.
	 */
	public abstract ArrayList<double[]> getDFTable();
	
	/**
	 * Interpolates the MDF values found in the DFTable for the given IML.
	 * 
	 * @param IML The desired Intensity Measure Level.
	 * @return The mean Damage Factor for the given IML.
	 */
	public abstract double getDF(double IML);

	/**
	 * Gets or creates the Damage Exceedance Matrix associated with the
	 * current vulnerability model.  This can either be precomputed and
	 * stored in memory (faster runtime, larger memory requirements), or
	 * it can be computed on the fly with an (assumed/given) distribution
	 * by using the MDF and COVDF.
	 * 
	 * @return The Damage Exceedance Matrix
	 */
	public abstract double[][] getDEMMatrix();
	
	/**
	 * Gets or computes the DF values that correspond the the Damage Exceedance
	 * Matrix.  This may or may not be the same as the regular MDF values depending
	 * on implementation.
	 * 
	 * @return The Damage Factor values associated with the DEM.
	 */
	public abstract double[] getDEMDFVals();
	
	////////////////////////////////////////////////////////////////////////////////
	//                              Private Functions                             //
	////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Do not use this constructor.  This class is abstract.
	 */
	protected VulnerabilityModel() {}
}
