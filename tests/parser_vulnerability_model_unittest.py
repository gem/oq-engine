# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright (c) 2010-2011, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License version 3
# only, as published by the Free Software Foundation.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License version 3 for more details
# (a copy is included in the LICENSE file that accompanied this code).
#
# You should have received a copy of the GNU Lesser General Public License
# version 3 along with OpenQuake.  If not, see
# <http://www.gnu.org/licenses/lgpl-3.0.txt> for a copy of the LGPLv3 License.




import os
import unittest

from tests.utils import helpers
from openquake import shapes
from openquake import kvs
from openquake.parser import vulnerability

TEST_FILE = "examples/vulnerability-model-discrete.xml"
NO_OF_CURVES_IN_TEST_FILE = 4


class VulnerabilityModelTestCase(unittest.TestCase):

    def setUp(self):
        self.parser = vulnerability.VulnerabilityModelFile(
                os.path.join(helpers.SCHEMA_DIR, TEST_FILE))

        # delete server side cached data
        kvs.flush()

    def test_loads_all_the_functions_defined(self):
        counter = 0

        for (counter, vulnerability_curve) in enumerate(self.parser):
            counter += 1

        self.assertEqual(NO_OF_CURVES_IN_TEST_FILE, counter)

    def test_loads_the_functions_data(self):
        model = self._load_vulnerability_model()

        self.assertEqual("MMI", model["PK"]["IMT"])
        self.assertEqual("fatalities", model["PK"]["lossCategory"])
        self.assertEqual("PAGER", model["PK"]["vulnerabilitySetID"])
        self.assertEqual("population", model["PK"]["assetCategory"])
        self.assertEqual("LN", model["PK"]["probabilisticDistribution"])

        self.assertEqual([0.00, 0.00, 0.00, 0.00, 0.00, 0.01,
                0.06, 0.18, 0.36, 0.36, 0.36],
                model["PK"]["lossRatio"])

        self.assertEqual([0.30, 0.30, 0.30, 0.30, 0.30, 0.30,
                0.30, 0.30, 0.30, 0.30, 0.30],
                model["PK"]["coefficientsVariation"])

        self.assertEqual([5.00, 5.50, 6.00, 6.50, 7.00, 7.50,
                8.00, 8.50, 9.00, 9.50, 10.00],
                model["PK"]["IML"])

        self.assertEqual([0.00, 0.00, 0.00, 0.00, 0.00, 0.01,
                0.06, 0.18, 0.36, 0.36, 0.36],
                model["IR"]["lossRatio"])

        self.assertEqual([0.30, 0.30, 0.30, 0.30, 0.30, 0.30,
                0.30, 0.30, 0.30, 0.30, 0.30],
                model["IR"]["coefficientsVariation"])

        self.assertEqual([5.00, 5.50, 6.00, 6.50, 7.00, 7.50,
                8.00, 8.50, 9.00, 9.50, 10.00],
                model["IR"]["IML"])

        self.assertEqual("NPAGER", model["AA"]["vulnerabilitySetID"])

        self.assertEqual([6.00, 6.50, 7.00, 7.50, 8.00, 8.50,
                9.00, 9.50, 10.00, 10.50, 11.00],
                model["AA"]["IML"])

        self.assertEqual([0.50, 0.50, 0.50, 0.50, 0.50, 0.50,
                0.50, 0.50, 0.50, 0.50, 0.50],
                model["AA"]["coefficientsVariation"])

    def test_loading_and_storing_model_in_kvs(self):
        path = os.path.join(helpers.SCHEMA_DIR, TEST_FILE)
        vulnerability.load_vulnerability_model(1234, path)
        model = vulnerability.load_vuln_model_from_kvs(1234)

        self.assertEqual(NO_OF_CURVES_IN_TEST_FILE, len(model))

        expected_curve = shapes.Curve([
                (5.0, (0.00, 0.3)), (5.5, (0.00, 0.3)),
                (6.0, (0.00, 0.3)), (6.5, (0.00, 0.3)),
                (7.0, (0.00, 0.3)), (7.5, (0.01, 0.3)),
                (8.0, (0.06, 0.3)), (8.5, (0.18, 0.3)),
                (9.0, (0.36, 0.3)), (9.5, (0.36, 0.3)),
                (10.0, (0.36, 0.3))])

        self.assertEqual(expected_curve, model["PK"])
        self.assertEqual(expected_curve, model["IR"])

    def _load_vulnerability_model(self):
        model = {}

        for vulnerability_function in self.parser:
            model[vulnerability_function["ID"]] = vulnerability_function

        return model
